---
title: "Marketing Analytics - Trabalho Final"
authors:
  - name: Michel Maurice Conjaud
  - name: Hélio Pereira Oliveira
  - name: Renan Cabral
  - name: Tiago Evangelista Pardo
format:
  html:
    code-fold: true
    embed-resources: true
    smooth-scroll: true
    theme: cerulean
    toc: true
    toc-expand: true
    toc-title: "Sumário"
    toc_float: true

execute:
  freeze: true
  warning: false
  cache: true
---

# Projeto Final Marketing Analytics

```{r setup, include=FALSE}
library(tidyverse)
library(skimr)
library(dplyr)
library(tools4uplift)
library(tidymodels)
library(ggplot2)
library(caret)
```

Vamos analisar uma base de Marketing para uma campanha de promoção 2 por 1 (BOGO - Buy one get one).

Buscamos entender os efeitos da campanha sobre a conversão de vendas e minimização dos custos da campanha.

Base de dados:

https://www.kaggle.com/datasets/davinwijaya/customer-retention

(A base é fictícia e foi criada para treinamento de análises e modelos preditivos)

Temos duas campanhas de marketing:

- Uma campanha de marketing para a promoção de desconto;

- Uma campanha de marketing para a promoção de "Buy one get one" (BOGO).

Vamos buscar entender sua eficácia e qual possui melhor desempenho.

```{r}
vendas <- read.csv("data.csv")
```

Exploração Inicial da Base:

-   **recency**: Número de meses desde a última compra do cliente.
-   **history**: Valor total gasto pelo cliente até agora.
-   **used_discount**: Indica se o cliente usou um cupom de desconto em compras anteriores (1 para sim, 0 para não).
-   **used_bogo**: Indica se o cliente utilizou uma promoção do tipo "compre um, leve outro" (BOGO) em compras anteriores (1 - para sim, 0 para não).
-   **zip_code**: Categoria do código postal do cliente (Surburban, Rural, Urban).
-   **is_referral**: Indica se o cliente foi referido por outro cliente (1 para sim, 0 para não).
-   **channel**: Canal pelo qual o cliente realizou a última compra (Phone, Web).
-   **offer**: Tipo de oferta que foi enviada ao cliente (Buy One Get One, No Offer, Discount).
-   **conversion**: Indica se a campanha de marketing resultou em uma conversão/purchase (1 para sim, 0 para não).

```{r, include=FALSE}
vendas %>% skim()
```

```{r}
vendas %>% head()
```

## Vamos analisar a distribuição das características dos clientes:

Análise demográfica - Temos apenas 2 características demográficas: 'zip_code' e 'channel'.

(Obs.: Além das características demográficas precismamos analisar também outras características do cliente como a recência, o histórico (total gasto) e se o cliente foi referido)

```{r, include=FALSE}
# Criar uma função auxiliar para adicionar porcentagens aos gráficos de barra
add_percentages <- function(ggplot_object, data) {
  ggplot_object +
    geom_text(stat = 'count', aes(label = scales::percent(..count../sum(..count..))), 
              vjust = -0.5, color = "black")
}
```

### Distribuição por zona (zip code):

```{r}
# Gráfico de barras para 'zip_code'
gg_zip_code <- vendas %>%
  ggplot(aes(x = zip_code, fill = zip_code)) +
  geom_bar() +
  labs(title = "Distribuição dos Clientes por Zip Code",
       x = "Zip Code",
       y = "Contagem") +
  scale_fill_manual(values = c("Surburban" = "#FFD700", "Rural" = "#4CAF50", "Urban" = "#2196F3"))

gg_zip_code <- add_percentages(gg_zip_code, vendas)
print(gg_zip_code)
```

### Distribuição por canal de compra:

```{r}
# Gráfico de barras para 'channel'
gg_channel <- vendas %>%
  ggplot(aes(x = channel, fill = channel)) +
  geom_bar() +
  labs(title = "Distribuição dos Canais de Compra",
       x = "Canal",
       y = "Contagem") +
  scale_fill_manual(values = c("Phone" = "#FF5722", "Web" = "#3F51B5", "Multichannel" = "#94928b"))

gg_channel <- add_percentages(gg_channel, vendas)
print(gg_channel)
```

### Distribuição por tipo de oferta:

```{r}
# Gráfico de barras para 'offer'
gg_offer <- vendas %>%
  ggplot(aes(x = offer, fill = offer)) +
  geom_bar() +
  labs(title = "Distribuição dos Tipos de Oferta",
       x = "Oferta",
       y = "Contagem") +
  scale_fill_manual(values = c("Buy One Get One" = "#9C27B0", "No Offer" = "#00BCD4", "Discount" = "#E91E63"))

gg_offer <- add_percentages(gg_offer, vendas)
print(gg_offer)
```

Vemos que a distribuição das amostras está distribuída igualmente entre os 3 tipos de oferta (BOGO, No Offer, Discount).

### Distribuição demográfica por tipo de oferta:

```{r}
# Gráfico de barras para 'zip_code' por cada grupo de 'offer'
gg_zip_offer <- vendas %>%
  ggplot(aes(x = zip_code, fill = zip_code)) +
  geom_bar(position = position_dodge()) +
  facet_wrap(~ offer, scales = "free_y") + # Cada painel representa um tipo de oferta
  labs(title = "Distribuição de Zip Code por Tipo de Oferta",
       x = "Zip Code",
       y = "Contagem") +
  scale_fill_manual(values = c("Surburban" = "#FFD700", "Rural" = "#4CAF50", "Urban" = "#2196F3")) +
  theme_minimal()

# Adicionando porcentagens aos gráficos
gg_zip_offer <- gg_zip_offer +
  geom_text(stat = 'count', aes(label = scales::percent(..count../sum(..count..), accuracy = 0.1)),
            position = position_dodge(width = 0.9), vjust = -0.5, size = 3)

print(gg_zip_offer)
```

Verificamos que a distribuição de 'Área' é similar entre os grupos de oferta. Logo esse fator n deve afetar a amostragem.

```{r}
# Gráfico de barras para 'channel' por cada grupo de 'offer'
gg_zip_offer <- vendas %>%
  ggplot(aes(x = channel, fill = channel)) +
  geom_bar(position = position_dodge()) +
  facet_wrap(~ offer, scales = "free_y") + # Cada painel representa um tipo de oferta
  labs(title = "Distribuição de Canal de compra por Tipo de Oferta",
       x = "Canal de Compra",
       y = "Contagem") +
  scale_fill_manual(values = c("Phone" = "#FF5722", "Web" = "#3F51B5", "Multichannel" = "#94928b")) +
  theme_minimal()

# Adicionando porcentagens aos gráficos
gg_zip_offer <- gg_zip_offer +
  geom_text(stat = 'count', aes(label = scales::percent(..count../sum(..count..), accuracy = 0.1)),
            position = position_dodge(width = 0.9), vjust = -0.5, size = 3)

print(gg_zip_offer)
```

Assim como a área a distribuição de 'Canal de Compra' é similar entre os grupos de oferta e não deve afetar a análise dos efeitos da campanha.

------------------------------------------------------------------------

## Análise dos efeitos da Campanha

Vamos agora analisar os efeitos em conversão entre campanhas e grupo de controle

### Teste A/B:

```{r}
# Gráfico de barras para 'conversion' por cada grupo de 'offer', com o eixo x representando apenas conversão
gg_conversion_offer <- vendas %>%
  ggplot(aes(x = as.factor(conversion), fill = as.factor(conversion))) +
  geom_bar(position = position_dodge()) +
  facet_wrap(~ offer, scales = "free_y") + # Cada painel representa um tipo de oferta
  labs(title = "Conversão de Vendas por Tipo de Oferta",
       x = "Conversão (0 = Não, 1 = Sim)",
       y = "Contagem",
       fill = "Conversão") +
  scale_fill_manual(values = c("0" = "#FF6347", "1" = "#32CD32")) + # Cores para não conversão e conversão
  theme_minimal()

# Adicionando porcentagens aos gráficos
gg_conversion_offer <- gg_conversion_offer +
  geom_text(stat = 'count', aes(label = scales::percent(..count../sum(..count..), accuracy = 0.1)),
            position = position_dodge(width = 0.9), vjust = -0.5, size = 3)

print(gg_conversion_offer)
```

Validamos assim via teste A/B que ambas as campanhas de marketing (BOGO e Discount) tiveram um efeito positivo na conversão de vendas.

```{r}
# Calcular a taxa de conversão para cada grupo de oferta
conversion_rates <- vendas %>%
  group_by(offer) %>%
  summarise(conversion_rate = mean(conversion)*100) %>%
  ungroup()

# Encontrar a taxa de conversão do grupo de controle (No Offer)
control_rate <- conversion_rates %>%
  filter(offer == "No Offer") %>%
  pull(conversion_rate)

# Calcular o aumento de vendas para cada uma das campanhas em relação ao grupo de controle
conversion_increase <- conversion_rates %>%
  mutate(increase = ifelse(offer == "No Offer", NA, (conversion_rate - control_rate) / control_rate * 100))

# Mostrar os resultados, incluindo o grupo de controle
conversion_increase
```

Verificamos um aumento de 72% na taxa de conversão para campanha de descontos e 42% para a campanha BOGO em relação ao grupo de controle.

Temos assim uma indicação inicial de que a campanha de BOGO pode não ser tão eficas para a conversão quanto um desconto tradicional.

Porém precisamos analisar agora se apesar do menor impacto absoluto qual das campanhas apresenta maior potencial de uplift.

Assim qual o efeito das campanhas de acordo com a população exposta.


### Vamos agora separar a base de acordo com os tratamentos para podermos realizar algumas análises individuais:

- BOGO (Buy One Get One)

- Discount (Desconto)

```{r}
vendas_bogo <- vendas %>%
  filter(offer == "Buy One Get One" | offer == "No Offer")  # Apenas BOGO e grupo de controle

vendas_discount <- vendas %>%
  filter(offer == "Discount" | offer == "No Offer")  # Apenas Discount e grupo de controle
```


### Modelos Uplift:

Vamos analisar agora, aplicando um modelo Uplift sem descrição da campanha de marketing enviada (analisando o efeito de ambas juntas)

```{r, include=FALSE}
# Convertendo variáveis categóricas em dummies
uplift_data <- vendas %>%
  mutate(
    channel = as.factor(channel),
    zip_code = as.factor(zip_code),
    treat = ifelse(offer == "No Offer", 0, 1),  # Indicador de tratamento binário
    offerDiscount = ifelse(offer == "Discount", 1, 0),  # Tratamento específico para Discount
    offerBOGO = ifelse(offer == "Buy One Get One", 1, 0)  # Tratamento específico para BOGO
  ) %>%
  model.matrix(~ channel + zip_code + treat + offerDiscount + offerBOGO - 1, data = .) %>%
  as.data.frame() %>%
  cbind(vendas, .) %>%
  select(-c(channel, zip_code, offer))  # Removendo as colunas originais categóricas
```

#### Preparando as bases de dados para os conjuntos das 2 campanhas:

- Transformamos as variáveis qualitativas em dummies (One-hot enconding)
- Criamos uma variável "flag" para casos de tratamento
- Removemos as variáveis que poderiam causar algum data leak no modelo.

```{r}
uplift_data_bogo <- vendas_bogo %>% 
  mutate(
    channel = as.factor(channel),
    zip_code = as.factor(zip_code),
    treat = ifelse(offer == "No Offer", 0, 1),  # Indicador de tratamento binário
  ) %>%
  model.matrix(~ channel + zip_code + treat - 1, data = .) %>%
  as.data.frame() %>%
  cbind(vendas_bogo, .) %>%
  select(-c(channel, zip_code, offer))  # Removendo as colunas originais categóricas
```

```{r}
uplift_data_discount <- vendas_discount %>% 
  mutate(
    channel = as.factor(channel),
    zip_code = as.factor(zip_code),
    treat = ifelse(offer == "No Offer", 0, 1),  # Indicador de tratamento binário
  ) %>%
  model.matrix(~ channel + zip_code + treat - 1, data = .) %>%
  as.data.frame() %>%
  cbind(vendas_discount, .) %>%
  select(-c(channel, zip_code, offer))  # Removendo as colunas originais categóricas
```


```{r}
head(uplift_data)
```
Separando as bases em treinamento e teste:

```{r}
#Vamos separar a base em treinamento e teste para os modelos uplift:
set.seed(123)

split_uplift_bogo <- SplitUplift(data = uplift_data_bogo, p = 0.8, group = c("treat", "conversion"))
split_uplift_discount <- SplitUplift(data = uplift_data_discount, p = 0.8, group = c("treat", "conversion"))

uplift_treinamento_bogo <- split_uplift_bogo[[1]]
uplift_test_bogo <- split_uplift_bogo[[2]]

uplift_treinamento_discount <- split_uplift_discount[[1]]
uplift_test_discount <- split_uplift_discount[[2]]
```

Definindo as variaveis preditoras:

```{r}
#Definindo variáveis preditoras:

predictors_bogo <- setdiff(names(uplift_treinamento_bogo), c("conversion", "treat"))
predictors_discount <- setdiff(names(uplift_treinamento_discount), c("conversion", "treat"))
```

#### Modelo Uplift: Two-model estimator

```{r}
dual_uplift_model_bogo <- DualUplift(
  data = uplift_treinamento_bogo,  # fornecendo a base de dados
  treat = 'treat',  # especificando a coluna de tratamento
  outcome = 'conversion',  # especificando a variável de resultado
  predictors = predictors_bogo  # fornecendo a lista de preditores
)

dual_uplift_model_discount <- DualUplift(
  data = uplift_treinamento_discount,  # fornecendo a base de dados
  treat = 'treat',  # especificando a coluna de tratamento
  outcome = 'conversion',  # especificando a variável de resultado
  predictors = predictors_discount  # fornecendo a lista de preditores
)
```

Vamos analisar os resultados dos modelos para as duas campanhas:

1. Campanha BOGO:

```{r}
#Análise dos resultados do modelo BOGO:
print(summary(dual_uplift_model_bogo))
```
2. campanha Discount:

```{r}
#Análise dos resultados do modelo Discount:
print(summary(dual_uplift_model_discount))
```

Observando os resultados do nosso modelo para grupo de controle e campanhas combinadas:

REVISAR CONCLUSÕES DOS MODELOS UPLIFTS


#### Modelo Uplift: Interaction estimator

```{r}
inter_uplift_model_bogo <- InterUplift(
  data = uplift_treinamento_bogo,  # fornecendo a base de dados
  treat = 'treat',  # especificando a coluna de tratamento
  outcome = 'conversion',  # especificando a variável de resultado
  predictors = predictors_bogo  # fornecendo a lista de preditores
)

inter_uplift_model_discount <- InterUplift(
  data = uplift_treinamento_discount,  # fornecendo a base de dados
  treat = 'treat',  # especificando a coluna de tratamento
  outcome = 'conversion',  # especificando a variável de resultado
  predictors = predictors_discount  # fornecendo a lista de preditores
)
```
 
Vamos avaliar os modelos construídos:

1. Campanha BOGO:

```{r}
print(summary(inter_uplift_model_bogo))
```
2. Campanha Discount:

```{r}
print(summary(inter_uplift_model_discount))
```


### Vamos realizar as predições e salvar os resultados para análise uplift das campanhas:

```{r}
#Vamos realizar as predições com os modelos gerados para analisar o resultado:
set.seed(123)

#Predições de modelos Dual Uplift:

predicoes_dual_uplift_bogo <- predict.DualUplift(
  dual_uplift_model_bogo, 
  newdata= uplift_test_bogo
  )

predicoes_dual_uplift_discount <- predict.DualUplift(
  dual_uplift_model_discount, 
  newdata= uplift_test_discount
  )

#Predições de modelos Inter Uplift:

predicoes_inter_bogo <- predict.InterUplift(
  inter_uplift_model_bogo, 
  newdata= uplift_test_bogo,
  treat = "treat"
  )

predicoes_inter_discount <- predict.InterUplift(
  inter_uplift_model_discount,
  newdata= uplift_test_discount,
  treat = "treat"
  )
```

Salvando os resultados:

```{r}
#Salvando os resultados de predição:

#uplift_teste$predito_dual_uplift <- predicoes_dual_uplift

uplift_test_bogo$predito_dual_uplift <- predicoes_dual_uplift_bogo
uplift_test_discount$predito_dual_uplift <- predicoes_dual_uplift_discount

uplift_test_bogo$predito_inter_uplift <- predicoes_inter_bogo
uplift_test_discount$predito_inter_uplift <- predicoes_inter_discount
```

### Vamos por fim analisar a performance dos modelos após realizar as predições:

```{r}

#Performance de modelos Dual Uplift:

performance_dual_uplift_bogo <- PerformanceUplift(
  data = uplift_test_bogo, 
  treat = "treat", 
  outcome = "conversion", 
  prediction="predito_dual_uplift", 
  nb.group = 50
  )

performance_dual_uplift_discount <- PerformanceUplift(
  data = uplift_test_discount, 
  treat = "treat", 
  outcome = "conversion", 
  prediction="predito_dual_uplift", 
  nb.group = 50
  )

#Performance de modelos Inter Uplift:

performance_inter_uplift_bogo <- PerformanceUplift(
  data = uplift_test_bogo, 
  treat = "treat", 
  outcome = "conversion", 
  prediction="predito_inter_uplift", 
  nb.group = 50
  )

performance_inter_uplift_discount <- PerformanceUplift(
  data = uplift_test_discount, 
  treat = "treat", 
  outcome = "conversion", 
  prediction="predito_inter_uplift", 
  nb.group = 50
  )
```

ADICIONAR OS PLOTS E ANÁLISE DOS RESULTADOS:


### Curva de QINI:

(Atenção aos valores dos eixos - campanhas de desconto tem um valor máximo maior)


```{r}
# Configurar a área de plotagem para 4 gráficos (2x2)
par(mfrow=c(2,2))

# Plotar cada gráfico de uplift
# Uplift Dual BOGO
plot(performance_dual_uplift_bogo, type = "b", lwd = 1, col="blue4", main="Dual Uplift - BOGO")

# Uplift Dual Discount
plot(performance_dual_uplift_discount, type = "b", lwd = 1, col="red4", main="Dual Uplift - Discount")

# Uplift Inter BOGO
plot(performance_inter_uplift_bogo, type = "b", lwd = 1, col="blue4", main="Inter Uplift - BOGO")

# Uplift Inter Discount
plot(performance_inter_uplift_discount, type = "b", lwd = 1, col="red4", main="Inter Uplift - Discount")

# Restaurar configuração padrão do par
par(mfrow=c(1,1))

```

#### Avaliando a área de QINI:

```{r}
# Cálculo da Área Qini para cada modelo
qini_bogo_dual <- round(QiniArea(performance_dual_uplift_bogo, adjusted=TRUE), 2)
qini_discount_dual <- round(QiniArea(performance_dual_uplift_discount, adjusted=TRUE), 2)
qini_bogo_inter <- round(QiniArea(performance_inter_uplift_bogo, adjusted=TRUE), 2)
qini_discount_inter <- round(QiniArea(performance_inter_uplift_discount, adjusted=TRUE), 2)

# Criando uma tabela para mostrar os valores
qini_results <- data.frame(
  Model = c("Dual Uplift BOGO", "Dual Uplift Discount", "Inter Uplift BOGO", "Inter Uplift Discount"),
  Qini_Area = c(qini_bogo_dual, qini_discount_dual, qini_bogo_inter, qini_discount_inter)
)

# Imprimindo a tabela com os valores da área Qini
print(qini_results)
```

Os modelos Two-model (Dual) e o Interaction (Inter) apresentaram resultados iguais entre si em termos de desempenho de Qini.

Desta forma podemos seguir com qualquer um deles para maiores análises, vamos seguir com o Inter por ser no geral mais robusto.

Com relação ao desempenho QINI da campanha de desconto ela apresenta um valor pior que "random targetting".

## Comparação das Campanhas:

```{r}
# Configurando a área de plotagem para dois gráficos lado a lado
par(mfrow=c(1,2))

# Plotar o gráfico de Qini para a campanha BOGO usando o modelo Inter Uplift
plot(performance_inter_uplift_bogo, type = "l", lwd = 2, col="blue", main="Qini - BOGO Campaign")

# Plotar o gráfico de Qini para a campanha Discount usando o modelo Inter Uplift
plot(performance_inter_uplift_discount, type = "l", lwd = 2, col="red", main="Qini - Discount Campaign")

# Restaurar configuração padrão do par
par(mfrow=c(1,1))

```

```{r}
# Obtenha os valores máximos e mínimos dos dados para ambos os gráficos
max_value <- max(max(performance_inter_uplift_bogo$uplift), max(performance_inter_uplift_discount$uplift))
min_value <- min(min(performance_inter_uplift_bogo$uplift), min(performance_inter_uplift_discount$uplift))

# Configurando a área de plotagem para dois gráficos lado a lado
par(mfrow=c(1,2))

# Primeiro gráfico para BOGO
barplot(performance_inter_uplift_bogo, col="blue4", main="Variação Uplift Incremental - BOGO",
        ylim=c(min_value, max_value))

# Segundo gráfico para Discount
barplot(performance_inter_uplift_discount, col="red4", main="Variação Uplift Incremental - Discount",
        ylim=c(min_value, max_value))

# Restaurar configuração padrão do par
par(mfrow=c(1,1))

```

## Conclusão:

Apesar das campanhas de marketing voltadas para promoção de disconto terem um resultado cumulativo melhor as campanhas de BOGO apresentam um desempenho uplift melhor, assim é necessário menor volume para um mesmo resultado para populações menores de marketing.

Desta forma para campanhas que buscam apenas o maior efeito sem necessidade de otimização podemos preferir uma campanha de desconto.

### Revisando distribuição de algumas variáveis com relação aos resultados:

#### Uso de Desconto:

```{r}
# Preparação dos dados e cálculo das porcentagens para 'used_discount'
data_for_plot_discount <- vendas %>%
  filter(conversion == 1) %>%
  group_by(offer, used_discount) %>%
  summarise(Total = n(), .groups = 'drop') %>%
  group_by(offer) %>%
  mutate(Percent = (Total / sum(Total)) * 100)

# Criando o gráfico de barras para porcentagem de distribuição de 'used_discount' para conversões positivas por tipo de oferta
gg_discount_conversion_by_offer <- ggplot(data_for_plot_discount, aes(x = as.factor(used_discount), y = Percent, fill = as.factor(used_discount))) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_text(aes(label = sprintf("%.1f%%", Percent)),
            position = position_dodge(width = 0.7), vjust = -0.5, size = 3) +
  labs(title = "Distribuição de Uso de Discount em Conversões Positivas por Tipo de Oferta",
       x = "Used Discount (0 = Não Usado, 1 = Usado)",
       y = "Percentual (%)") +
  facet_wrap(~ offer, scales = "free_y") +
  scale_fill_manual(values = c("0" = "red4", "1" = "blue4")) +
  theme_minimal()

# Imprimir o gráfico
print(gg_discount_conversion_by_offer)

```

#### Uso de BOGO:

```{r}
# Preparação dos dados e cálculo das porcentagens de conversão para 'used_bogo'
data_for_plot_bogo <- vendas %>%
  filter(conversion == 1) %>%
  group_by(offer, used_bogo) %>%
  summarise(Total = n(), .groups = 'drop') %>%
  group_by(offer) %>%
  mutate(Percent = (Total / sum(Total)) * 100)

# Criando o gráfico de barras para porcentagem de distribuição de 'used_bogo' para conversões positivas por tipo de oferta
gg_bogo_conversion_by_offer <- ggplot(data_for_plot_bogo, aes(x = as.factor(used_bogo), y = Percent, fill = as.factor(used_bogo))) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_text(aes(label = sprintf("%.1f%%", Percent)),
            position = position_dodge(width = 0.7), vjust = -0.5, size = 3) +
  labs(title = "Distribuição de Uso de BOGO em Conversões Positivas por Tipo de Oferta",
       x = "Used BOGO (0 = Não Usado, 1 = Usado)",
       y = "Percentual (%)") +
  facet_wrap(~ offer, scales = "free_y") +
  scale_fill_manual(values = c("0" = "red4", "1" = "blue4")) +
  theme_minimal()

# Imprimir o gráfico
print(gg_bogo_conversion_by_offer)

```


#### Indicação de terceiros:

```{r}
# Preparação dos dados e cálculo das porcentagens de conversão para 'is_referral'
data_for_plot_referral <- vendas %>%
  filter(conversion == 1) %>%
  group_by(offer, is_referral) %>%
  summarise(Total = n(), .groups = 'drop') %>%
  group_by(offer) %>%
  mutate(Percent = (Total / sum(Total)) * 100)

# Criando o gráfico de barras para porcentagem de distribuição de 'is_referral' para conversões positivas por tipo de oferta
gg_referral_conversion_by_offer <- ggplot(data_for_plot_referral, aes(x = as.factor(is_referral), y = Percent, fill = as.factor(is_referral))) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.7) +
  geom_text(aes(label = sprintf("%.1f%%", Percent)),
            position = position_dodge(width = 0.7), vjust = -0.5, size = 3) +
  labs(title = "Distribuição de Referências em Conversões Positivas por Tipo de Oferta",
       x = "Is Referral (0 = Não, 1 = Sim)",
       y = "Percentual (%)") +
  facet_wrap(~ offer, scales = "free_y") +
  scale_fill_manual(values = c("0" = "red4", "1" = "blue4")) +
  theme_minimal()

# Imprimir o gráfico
print(gg_referral_conversion_by_offer)
```

